package com.mbeddr.cpp.classes.behavior;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

/*package*/ class CppMemberVisibilityStrategy implements ICppMemberVisibilityStrategy {
  private static boolean DEBUG_VISIBILITY_STRATEGY = false;

  public CppMemberVisibilityStrategy() {
  }

  public Iterable<SNode> getVisibleOutsideMembers(SNode theClassifier) {
    return getAllPublicMembers(theClassifier);
  }

  public Iterable<SNode> getAllPrivateMembers(SNode theClassifier) {

    Iterable<SNode> result;


    if (theClassifier instanceof SNode) {
      result = getAllPrivateMembersFromClass(SNodeOperations.cast(theClassifier, "com.mbeddr.cpp.classes.structure.ClassDeclaration"));
    } else {
      result = new ArrayList<SNode>();
    }

    debug("Result of getAllPrivateMembers of " + theClassifier + ": " + result);

    return result;

  }

  public Iterable<SNode> getAllPublicMembers(SNode theClassifier) {
    Iterable<SNode> result;

    if (theClassifier instanceof SNode) {

      result = getAllPublicMembersFromClass(SNodeOperations.cast(theClassifier, "com.mbeddr.cpp.classes.structure.ClassDeclaration"));
    } else {
      result = getAllPublicMembersFromClassifier(theClassifier);
    }

    debug("Result of getAllPublicMembers of " + theClassifier + ": " + result);

    return result;
  }

  public Iterable<SNode> getAllProtectedMembers(SNode theClassifier) {

    Iterable<SNode> result;


    if (theClassifier instanceof SNode) {
      result = getAllProtectedMembersFromClass(SNodeOperations.cast(theClassifier, "com.mbeddr.cpp.classes.structure.ClassDeclaration"));
    } else {
      result = new ArrayList<SNode>();
    }

    debug("Result of getAllProtectedMembers of " + theClassifier + ": " + result);

    return result;
  }

  public Iterable<SNode> getVisibleInsideItselfMembers(SNode theClassifier) {
    debug("getVisible Inside Itself Members ()  called with the classifier: " + theClassifier);

    Iterable<SNode> result = Sequence.fromIterable(getAllPrivateMembers(theClassifier)).union(Sequence.fromIterable(getAllProtectedMembers(theClassifier))).union(Sequence.fromIterable(getAllPublicMembers(theClassifier)));

    debug("Result of getVisibleInsideItself: " + result);

    return result;
  }

  public Iterable<SNode> getVisibleInsideAnotherClassMembers(SNode theClassifier, SNode theAddressingClass) {
    if (theClassifier instanceof SNode) {
      return getVisibleInsideAnotherClassMembersFromClass(SNodeOperations.cast(theClassifier, "com.mbeddr.cpp.classes.structure.ClassDeclaration"), theAddressingClass);
    }

    return Classifier_Behavior.call_publicMembers_8616684942293671639(theClassifier);
  }

  private Iterable<SNode> getAllPublicMembersFromClass(SNode theClass) {
    Iterable<SNode> result = Sequence.fromIterable(Collections.<SNode>emptyList());

    result = Sequence.fromIterable(result).union(Sequence.fromIterable(Classifier_Behavior.call_publicMembers_8616684942293671639(theClass)));

    for (SNode inheritanceDefinition : SLinkOperations.getTargets(theClass, "inheritanceDefinitions", true)) {
      if (SPropertyOperations.hasValue(inheritanceDefinition, "inheritanceType", "2", "1")) {
        result = Sequence.fromIterable(result).union(Sequence.fromIterable(getAllPublicMembersFromClass(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false))));
      }
    }

    return result;
  }

  private Iterable<SNode> getAllPublicMembersFromClassifier(SNode theClassifier) {
    return Classifier_Behavior.call_publicMembers_8616684942293671639(theClassifier);
  }

  private Iterable<SNode> getAllProtectedMembersFromClass(SNode theClass) {
    Iterable<SNode> result = Sequence.fromIterable(Collections.<SNode>emptyList());

    result = Sequence.fromIterable(result).union(Sequence.fromIterable(ClassDeclaration_Behavior.call_protectedMembers_8616684942293671703(theClass)));

    for (SNode inheritanceDefinition : SLinkOperations.getTargets(theClass, "inheritanceDefinitions", true)) {
      if (SPropertyOperations.hasValue(inheritanceDefinition, "inheritanceType", "2", "1")) {
        result = Sequence.fromIterable(result).union(Sequence.fromIterable(getAllProtectedMembersFromClass(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false))));
      } else if (SPropertyOperations.hasValue(inheritanceDefinition, "inheritanceType", "3", "1")) {
        result = Sequence.fromIterable(result).union(Sequence.fromIterable(getAllProtectedMembersFromClass(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false))));
        result = Sequence.fromIterable(result).union(Sequence.fromIterable(getAllPublicMembers(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false))));
      }
    }

    return result;
  }

  private Iterable<SNode> getAllPrivateMembersFromClass(SNode theClass) {
    Iterable<SNode> result = Sequence.fromIterable(Collections.<SNode>emptyList());

    result = Sequence.fromIterable(result).union(Sequence.fromIterable(ClassDeclaration_Behavior.call_privateMembers_8616684942293671716(theClass)));

    for (SNode inheritanceDefinition : SLinkOperations.getTargets(theClass, "inheritanceDefinitions", true)) {
      if (SPropertyOperations.hasValue(inheritanceDefinition, "inheritanceType", "1", "1")) {
        result = Sequence.fromIterable(result).union(Sequence.fromIterable(getAllProtectedMembersFromClass(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false)))).union(Sequence.fromIterable(getAllPublicMembersFromClass(SLinkOperations.getTarget(inheritanceDefinition, "baseClass", false))));
      }
    }

    return result;

  }

  private Iterable<SNode> getVisibleInsideAnotherClassMembersFromClass(SNode theClass, SNode theAddressingClass) {

    debug("getVisibleInsideAnotherClassMembersFromClass called, theClass = " + theClass + " the AddressingClass = " + theAddressingClass);

    if (theClass == theAddressingClass) {
      debug("Classes are equal, returning visible inside itself!");
      return getVisibleInsideItselfMembers(theClass);
    }

    // Check for friendship 
    if (ClassDeclaration_Behavior.call_hasFriend_6865752029450306607(theClass, theAddressingClass)) {
      return getVisibleInsideItselfMembers(theClass);
    }

    // Inheritance should count here, have to clarify, how exactly it should work. 
    // Parent should know nothing about children. Actually, parent should not get such a child to process, normally. 
    // But child can know what aprent has, and can access what is inhereted. 
    Iterable<SNode> anscestorOfAddressingClass = ClassDeclaration_Behavior.call_getAllBaseClasses_5516725038417419344(theAddressingClass);
    if (Sequence.fromIterable(anscestorOfAddressingClass).contains(theClass)) {
      // TODO This code fragment needs additional checks, compilers compatibility. Not working with g++ :( 
      // Don't uncomment or delete 
      // <node> 
      // <node> 
      // <node> 
      // <node> 

      return getVisibleOutsideMembers(theClass);

    } else {
      // No inheritance relationship 
      return getVisibleOutsideMembers(theClass);
    }

  }

  private static void debug(String s) {
    if (DEBUG_VISIBILITY_STRATEGY) {
      System.out.println(s + " -- visibility strategy");
    }
  }
}
