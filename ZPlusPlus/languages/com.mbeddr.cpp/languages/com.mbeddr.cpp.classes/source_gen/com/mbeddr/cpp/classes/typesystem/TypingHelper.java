package com.mbeddr.cpp.classes.typesystem;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.typesystem.inference.TypeChecker;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import com.mbeddr.cpp.classes.behavior.Classifier_Behavior;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import com.mbeddr.cpp.classes.behavior.AbstractMethodDeclaration_Behavior;

public class TypingHelper {
  public TypingHelper() {
  }

  public boolean isSameType(SNode expected, SNode actual, SNode concept, SNode checkedClass) {
    if (SNodeOperations.isInstanceOf(expected, "com.mbeddr.cpp.classes.structure.ClassifierType") && SLinkOperations.getTarget(SNodeOperations.cast(expected, "com.mbeddr.cpp.classes.structure.ClassifierType"), "cls", false) == concept) {
      if (SNodeOperations.isInstanceOf(actual, "com.mbeddr.cpp.classes.structure.ClassifierType")) {
        return SLinkOperations.getTarget(SNodeOperations.cast(actual, "com.mbeddr.cpp.classes.structure.ClassifierType"), "cls", false) == checkedClass;
      }
      return false;
    }
    if (TypeChecker.getInstance().getSubtypingManager().isSubtype(expected, actual)) {
      return true;
    }
    return false;
  }

  public List<String> getConceptRealizationErrors(final SNode cls, final SNode concept) {
    List<String> report = ListSequence.fromList(new ArrayList<String>());
    Iterable<SNode> conceptMethods = Sequence.fromIterable(BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), concept, "virtual_allMembersOfThisClassOnly_1022708226502685404", new Object[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "com.mbeddr.cpp.classes.structure.MethodDeclaration");
      }
    });
    Iterable<SNode> classMethods = Sequence.fromIterable(Classifier_Behavior.call_publicMembers_8616684942293671639(cls)).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "com.mbeddr.cpp.classes.structure.MethodDeclaration");
      }
    });
    for (final SNode concMethod : Sequence.fromIterable(conceptMethods)) {
      Iterable<SNode> candidates = Sequence.fromIterable(classMethods).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SPropertyOperations.getString(it, "name").equals(SPropertyOperations.getString(concMethod, "name"));
        }
      });
      boolean matchFound = false;
      for (final SNode candidate : Sequence.fromIterable(candidates)) {
        if (ListSequence.fromList(SLinkOperations.getTargets(concMethod, "args", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(candidate, "args", true)).count() && isSameType(SLinkOperations.getTarget(concMethod, "type", true), SLinkOperations.getTarget(candidate, "type", true), concept, cls) && ListSequence.fromList(SLinkOperations.getTargets(concMethod, "args", true)).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSameType(SLinkOperations.getTarget(it, "type", true), SLinkOperations.getTarget(ListSequence.fromList(SLinkOperations.getTargets(candidate, "args", true)).getElement(SNodeOperations.getIndexInParent(it)), "type", true), concept, cls);
          }
        })) {
          matchFound = true;
          break;
        }
      }
      if (!(matchFound)) {
        ListSequence.fromList(report).addElement(AbstractMethodDeclaration_Behavior.call_signaturePresentation_2015268598019204067(concMethod) + " missing");
      }
    }
    return report;
  }

  public SNode detemplatifyType(SNode t, SNode cls, SNode templateInstance) {
    if (SNodeOperations.isInstanceOf(t, "com.mbeddr.cpp.classes.structure.TemplateParamType")) {
      return SNodeOperations.copyNode(TypeChecker.getInstance().getTypeOf(ListSequence.fromList(SLinkOperations.getTargets(templateInstance, "templateActuals", true)).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(SNodeOperations.cast(t, "com.mbeddr.cpp.classes.structure.TemplateParamType"), "param", false)))));
    } else {
      SNode copy = SNodeOperations.copyNode(t);
      List<SNode> templateParams = SNodeOperations.getDescendants(copy, "com.mbeddr.cpp.classes.structure.TemplateParamType", false, new String[]{});
      for (SNode p : ListSequence.fromList(templateParams)) {
        SNodeOperations.replaceWithAnother(p, SNodeOperations.copyNode(TypeChecker.getInstance().getTypeOf(ListSequence.fromList(SLinkOperations.getTargets(templateInstance, "templateActuals", true)).getElement(SNodeOperations.getIndexInParent(SLinkOperations.getTarget(p, "param", false))))));
      }
      return copy;
    }
  }

  public boolean hasTemplateParameterInType(SNode t) {
    return ListSequence.fromList(SNodeOperations.getDescendants(t, "com.mbeddr.cpp.classes.structure.TemplateParamType", true, new String[]{})).isNotEmpty();
  }
}
